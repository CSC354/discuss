// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.21.12
// source: protobufs/discuss/discuss.proto

package pdiscuss

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// DiscussClient is the client API for Discuss service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DiscussClient interface {
	NewArgument(ctx context.Context, in *NewArgumentRequest, opts ...grpc.CallOption) (*NewArgumentResponse, error)
	ReadArgument(ctx context.Context, in *ReadArgumentRequest, opts ...grpc.CallOption) (*ReadArgumentResponse, error)
	ReadResponses(ctx context.Context, in *ReadResponsesRequest, opts ...grpc.CallOption) (*Responses, error)
	ReadUserArguments(ctx context.Context, in *ReadUserArgumentsRequest, opts ...grpc.CallOption) (*Responses, error)
	ReadLatestArguments(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Responses, error)
	ReadLatestResponses(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Responses, error)
	AddTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*Ok, error)
	ReadTag(ctx context.Context, in *ReadTagRequest, opts ...grpc.CallOption) (*Tag, error)
}

type discussClient struct {
	cc grpc.ClientConnInterface
}

func NewDiscussClient(cc grpc.ClientConnInterface) DiscussClient {
	return &discussClient{cc}
}

func (c *discussClient) NewArgument(ctx context.Context, in *NewArgumentRequest, opts ...grpc.CallOption) (*NewArgumentResponse, error) {
	out := new(NewArgumentResponse)
	err := c.cc.Invoke(ctx, "/discuss.Discuss/NewArgument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussClient) ReadArgument(ctx context.Context, in *ReadArgumentRequest, opts ...grpc.CallOption) (*ReadArgumentResponse, error) {
	out := new(ReadArgumentResponse)
	err := c.cc.Invoke(ctx, "/discuss.Discuss/ReadArgument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussClient) ReadResponses(ctx context.Context, in *ReadResponsesRequest, opts ...grpc.CallOption) (*Responses, error) {
	out := new(Responses)
	err := c.cc.Invoke(ctx, "/discuss.Discuss/ReadResponses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussClient) ReadUserArguments(ctx context.Context, in *ReadUserArgumentsRequest, opts ...grpc.CallOption) (*Responses, error) {
	out := new(Responses)
	err := c.cc.Invoke(ctx, "/discuss.Discuss/ReadUserArguments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussClient) ReadLatestArguments(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Responses, error) {
	out := new(Responses)
	err := c.cc.Invoke(ctx, "/discuss.Discuss/ReadLatestArguments", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussClient) ReadLatestResponses(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Responses, error) {
	out := new(Responses)
	err := c.cc.Invoke(ctx, "/discuss.Discuss/ReadLatestResponses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussClient) AddTag(ctx context.Context, in *Tag, opts ...grpc.CallOption) (*Ok, error) {
	out := new(Ok)
	err := c.cc.Invoke(ctx, "/discuss.Discuss/AddTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussClient) ReadTag(ctx context.Context, in *ReadTagRequest, opts ...grpc.CallOption) (*Tag, error) {
	out := new(Tag)
	err := c.cc.Invoke(ctx, "/discuss.Discuss/ReadTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DiscussServer is the server API for Discuss service.
// All implementations must embed UnimplementedDiscussServer
// for forward compatibility
type DiscussServer interface {
	NewArgument(context.Context, *NewArgumentRequest) (*NewArgumentResponse, error)
	ReadArgument(context.Context, *ReadArgumentRequest) (*ReadArgumentResponse, error)
	ReadResponses(context.Context, *ReadResponsesRequest) (*Responses, error)
	ReadUserArguments(context.Context, *ReadUserArgumentsRequest) (*Responses, error)
	ReadLatestArguments(context.Context, *emptypb.Empty) (*Responses, error)
	ReadLatestResponses(context.Context, *emptypb.Empty) (*Responses, error)
	AddTag(context.Context, *Tag) (*Ok, error)
	ReadTag(context.Context, *ReadTagRequest) (*Tag, error)
	mustEmbedUnimplementedDiscussServer()
}

// UnimplementedDiscussServer must be embedded to have forward compatible implementations.
type UnimplementedDiscussServer struct {
}

func (UnimplementedDiscussServer) NewArgument(context.Context, *NewArgumentRequest) (*NewArgumentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewArgument not implemented")
}
func (UnimplementedDiscussServer) ReadArgument(context.Context, *ReadArgumentRequest) (*ReadArgumentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadArgument not implemented")
}
func (UnimplementedDiscussServer) ReadResponses(context.Context, *ReadResponsesRequest) (*Responses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadResponses not implemented")
}
func (UnimplementedDiscussServer) ReadUserArguments(context.Context, *ReadUserArgumentsRequest) (*Responses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadUserArguments not implemented")
}
func (UnimplementedDiscussServer) ReadLatestArguments(context.Context, *emptypb.Empty) (*Responses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadLatestArguments not implemented")
}
func (UnimplementedDiscussServer) ReadLatestResponses(context.Context, *emptypb.Empty) (*Responses, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadLatestResponses not implemented")
}
func (UnimplementedDiscussServer) AddTag(context.Context, *Tag) (*Ok, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTag not implemented")
}
func (UnimplementedDiscussServer) ReadTag(context.Context, *ReadTagRequest) (*Tag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadTag not implemented")
}
func (UnimplementedDiscussServer) mustEmbedUnimplementedDiscussServer() {}

// UnsafeDiscussServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DiscussServer will
// result in compilation errors.
type UnsafeDiscussServer interface {
	mustEmbedUnimplementedDiscussServer()
}

func RegisterDiscussServer(s grpc.ServiceRegistrar, srv DiscussServer) {
	s.RegisterService(&Discuss_ServiceDesc, srv)
}

func _Discuss_NewArgument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewArgumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscussServer).NewArgument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/discuss.Discuss/NewArgument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscussServer).NewArgument(ctx, req.(*NewArgumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Discuss_ReadArgument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadArgumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscussServer).ReadArgument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/discuss.Discuss/ReadArgument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscussServer).ReadArgument(ctx, req.(*ReadArgumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Discuss_ReadResponses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadResponsesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscussServer).ReadResponses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/discuss.Discuss/ReadResponses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscussServer).ReadResponses(ctx, req.(*ReadResponsesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Discuss_ReadUserArguments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadUserArgumentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscussServer).ReadUserArguments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/discuss.Discuss/ReadUserArguments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscussServer).ReadUserArguments(ctx, req.(*ReadUserArgumentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Discuss_ReadLatestArguments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscussServer).ReadLatestArguments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/discuss.Discuss/ReadLatestArguments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscussServer).ReadLatestArguments(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Discuss_ReadLatestResponses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscussServer).ReadLatestResponses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/discuss.Discuss/ReadLatestResponses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscussServer).ReadLatestResponses(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Discuss_AddTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Tag)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscussServer).AddTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/discuss.Discuss/AddTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscussServer).AddTag(ctx, req.(*Tag))
	}
	return interceptor(ctx, in, info, handler)
}

func _Discuss_ReadTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiscussServer).ReadTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/discuss.Discuss/ReadTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiscussServer).ReadTag(ctx, req.(*ReadTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Discuss_ServiceDesc is the grpc.ServiceDesc for Discuss service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Discuss_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "discuss.Discuss",
	HandlerType: (*DiscussServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NewArgument",
			Handler:    _Discuss_NewArgument_Handler,
		},
		{
			MethodName: "ReadArgument",
			Handler:    _Discuss_ReadArgument_Handler,
		},
		{
			MethodName: "ReadResponses",
			Handler:    _Discuss_ReadResponses_Handler,
		},
		{
			MethodName: "ReadUserArguments",
			Handler:    _Discuss_ReadUserArguments_Handler,
		},
		{
			MethodName: "ReadLatestArguments",
			Handler:    _Discuss_ReadLatestArguments_Handler,
		},
		{
			MethodName: "ReadLatestResponses",
			Handler:    _Discuss_ReadLatestResponses_Handler,
		},
		{
			MethodName: "AddTag",
			Handler:    _Discuss_AddTag_Handler,
		},
		{
			MethodName: "ReadTag",
			Handler:    _Discuss_ReadTag_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobufs/discuss/discuss.proto",
}
